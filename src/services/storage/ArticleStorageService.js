import { supabase } from '../../supabase/client.js';
import logger from '../../logger.js';

// Define the columns that actually exist in the Supabase 'articles' table
// IMPORTANT: Update this list to match your actual table schema
const VALID_ARTICLE_COLUMNS = [
    // 'id', // Assuming ID is auto-generated by DB
    'title',
    'url',
    'content',
    'published_at', // Check if your DB uses published_at or publishedAt
    'source',  
    'category',
    'created_at',   // Check if your DB uses created_at
    'updated_at',   // Check if your DB uses updated_at
    // Add any other valid columns like 'summary', 'author', etc.
];

export class ArticleStorageService {
  constructor() {
    logger.info('ArticleStorageService initialized');
  }

  async storeArticles(articles /*: InternalArticle[] */) {
    if (!articles || articles.length === 0) {
      logger.info('No articles provided to store.');
      return [];
    }
    logger.info('Storing articles in Supabase:', { count: articles.length });

    try {
      const articlesToStore = articles.map(article => {
        const dbArticle = {};
        // Only include valid columns that have a value in the internal article
        for (const col of VALID_ARTICLE_COLUMNS) {
          // Handle potential naming differences (e.g., publishedAt vs published_at)
          let value;
          if (col === 'published_at' && article.publishedAt) {
              value = article.publishedAt;
          } else if (col === 'source' && article.sourceName) {
              value = article.sourceName;
          } else if (col === 'created_at' && article.createdAt) {
              value = article.createdAt;
          } else if (col === 'updated_at' && article.updatedAt) {
              value = article.updatedAt;
          } else {
              value = article[col];
          }
          
          if (value !== undefined && value !== null) {
            dbArticle[col] = value;
          }
        }
        // Ensure mandatory fields have defaults if missing and allowed by DB
        // Example: if content is required but might be null from mapping
        // dbArticle.content = dbArticle.content || 'N/A'; 
        return dbArticle;
      });
      
      // Filter out any potentially empty objects after mapping if needed
      const validArticlesToStore = articlesToStore.filter(a => Object.keys(a).length > 0);
      
      if(validArticlesToStore.length === 0) {
          logger.warn("No valid articles to store after mapping to DB schema.");
          return [];
      }

      logger.debug('Articles prepared for Supabase upsert:', { sample: validArticlesToStore[0], count: validArticlesToStore.length });

      // Upsert using only valid columns
      // Let Supabase handle ID generation. onConflict needs a UNIQUE constraint in DB.
      const { data, error } = await supabase
        .from('articles')
        .upsert(validArticlesToStore, {
            // onConflict: 'url', // Re-enable ONLY if url has a UNIQUE constraint in DB
            ignoreDuplicates: false // Set to false if using onConflict, true otherwise might mask issues
        }); // Relying on Primary Key conflict by default if id isn't generated by DB

      if (error) {
        logger.error('Supabase upsert error:', { 
            message: error.message, 
            details: error.details, 
            hint: error.hint,
            code: error.code,
            attemptedDataSample: validArticlesToStore[0] // Log data sample on error
        });
        throw error; // Re-throw after logging
      }

      logger.info('Successfully stored/updated articles in Supabase:', {
        returnedCount: data?.length ?? 0
      });

      return data || []; // Return upserted data
      
    } catch (error) {
      logger.error('Error storing articles:', { message: error.message });
      // Decide if fetch should fail completely or just log storage error
      // For now, re-throwing to make it visible
      throw error;
    }
  }
} 